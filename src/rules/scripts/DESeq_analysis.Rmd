---
title: "PTPN Knockout"
author: "Kristen Wells"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    highlight: "tango"
    df_print: "paged"
    code_folding: "hide"
    self_contained: true
params:
  genome: "GRCm38"
  DE_alpha: 0.05
  DE_lfc: 1
  counts: "results/PTPN_KO_countTable_no_trim.txt"
  fastqc: "results/fastqc_summary.tsv"
  star_stats: "results/star_summary_no_trim.tsv"
  output_dir: "results/R_analysis"
  sample_info: "files/sample_info.csv"
  sample_column: "group"
  comparisons:
    value: 
      - ["WT_NoTreatment",        "PTPN2_KO_NoTreatment"]
      - ["WT_NoTreatment",        "WT_Cytokine_Treatment"]
      - ["PTPN2_KO_NoTreatment",  "PTPN2_KO_Cytokine_Treatment"]
      - ["WT_Cytokine_Treatment", "PTPN2_KO_Cytokine_Treatment"]
  genes:
    value:
      - "Ins1"
      - "Ins2"
      - "Gbp2"
      - "Gbp5"
      - "Cxcl1"
      - "Pomc"
---
```{r, setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/Users/wellskr/Documents/Analysis/Lori_sussel/Young_Kim/Sussel_RNASeq_PTPN/")
```

```{r "Load packages and set options", include = F}
install_packages <- function(install_list, name_list = NULL, 
                             install_cmd = "utils::install.packages", ...) {
  
  # If using devtools::install_github(), the package name will be different 
  # from the repository name in install_list
  if (is.null(name_list)) {
    name_list <- install_list
  }
  
  # Install packages
  for (i in 1:length(install_list)) {
    # require() returns TRUE invisibly if it was able to load package
    if (!require(name_list[i], character.only = T)) {
      
      install_pkg <- strsplit(install_cmd, "::")[[1]][1]
      
      if (!require(install_pkg, character.only = T)) {
        install.packages(install_pkg, dependencies = T, ...)
        require(install_pkg)
      }
      
      install_cmd <- paste0(install_cmd, "(install_list[i], ...)")
      eval(parse(text = install_cmd))
      
      require(name_list[i], character.only = T)
    }
  }
}

# Install CRAN packages
install_packages(c(
  "knitr",    "BiocManager",
  "cowplot",  "tidyverse", 
  "Matrix",   "pheatmap",
  "ggrepel",  "devtools", 
  "gprofiler2", "viridis",
  "RColorBrewer", "ashr",
  "apeglm"
))

# Install Bioconductor packages
install_packages(c(
  "DESeq2", "pathview",
  "KEGGREST", "org.Hs.eg.db"
), install_cmd = "BiocManager::install")

# Set default chunk options
opts_chunk$set(
  message = F, 
  warning = F,
  comment = ""
)
```


```{r "Load Functions and Theme"}
#############
# Functions # 
#############

# Find alignment quality
get_alignment_qual <- function(rate) {
  if (rate >= 85) {
    qual <- "high"
  } else if (rate >= 65) {
    qual <- "okay"
  } else {
    qual <- "low"
  }
  
  qual
}

# Create a PCA Plot
plot_pca <- function(vsd, group_by, color_palette = NULL){
  if(is.null(color_palette)){
    color_palette <- brewer.pal(length(levels(vsd[[group_by]])), "Set1")
    names(color_palette) <- levels(vsd[[group_by]])
  }
  pcaData <- plotPCA(vsd, intgroup = group_by, returnData = T)
    colnames(pcaData)[3] <- "group_by"
    percentVar <- round(100 * attr(pcaData, "percentVar"))
    pca_plot <- ggplot(data = pcaData,
                       mapping = aes(x = PC1,
                                     y = PC2,
                                     color = group_by)) +
    theme_classic() +
    geom_point(size = 3) +
    xlab(paste0("PC1: ", percentVar[1], "% variance")) +
    ylab(paste0("PC2: ", percentVar[2], "% variance")) +
    labs(color = group_by) +
    #coord_fixed() +
    scale_color_manual(values = color_palette)
return(pca_plot)
}


# Function to determine sample distances
get_distances <- function(vsd){
  sampleDists <- dist(t(assay(vsd)))
  sampleDistMatrix <- as.matrix(sampleDists)
  colnames(sampleDistMatrix) <- NULL
  colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
  dist_map <- pheatmap(sampleDistMatrix,
                       clustering_distance_rows=sampleDists,
                       clustering_distance_cols=sampleDists,
                       col=colors)
  return(dist_map)
}

# Function to return sig genes for a comparison
get_de <- function(object, column, var1, var2, write_csv = F,
                   p_value = 0.05, lfc = 0.5, lfc_shrink = TRUE,
                   output_dir){
  res <- DESeq2::results(object, contrast = c(column, var1, var2))
  if(lfc_shrink){
    res <- DESeq2::lfcShrink(object, contrast = c(column, var1, var2),
                             res = res, type = "ashr")
  }
  resOrdered <- res[order(res$pvalue), ]
  sigGenes <- resOrdered[!is.na(resOrdered$padj), ]
  sigGenes <- sigGenes[sigGenes$padj < p_value, ]
  sigGenes <- sigGenes[abs(sigGenes$log2FoldChange) > lfc, ]
  # Add columns for gene id and ens id
  sigGenes_colnames <- colnames(sigGenes)
  sigGenes$gene_name <- sub("_ENSMUSG.*", "", rownames(sigGenes))
  sigGenes$ens_id <- sub(".*_ENSMUSG", "ENSMUSG", rownames(sigGenes))
  # Place the new columns at the front
  sigGenes <- sigGenes[ , c("gene_name", "ens_id", sigGenes_colnames)]
  if(write_csv){
    file_name <- paste0(var1, "_vs_", var2, ".csv")
    write.csv(sigGenes,
              file = file.path(output_dir, "DE_files", file_name),
              row.names = FALSE)
  }
  return(list(DE_genes = sigGenes,
              DE_df = res))
}

# Function to make a heatmap
make_heatmap <- function(dds, de_genes, treatment, control, group,
                         print_genenames = FALSE, gene_identifier = "Gene_ID",
                         cluster_cols = FALSE, save_heatmap = TRUE,
                         output_dir = "/results/", plot_groups = "all",
                         color_test = NULL){
  # First make a "col data" data frame. This is just telling
  # pheatmap what you want to use to color the columns.
  df <- as.data.frame(colData(dds)[,c(group)])
  sample_info <- colData(dds)
  colnames(df) <- group
  rownames(df) <- rownames(colData(dds))
  # Pull out DE genes from the test we ran earlier, start with Gata6 KO
  genes <- rownames(de_genes)
  if(is.null(color_test)){
    color_test <- brewer.pal(length(levels(dds[[group]])), "Set1")
    names(color_test) <- levels(dds[[group]])
  }
  coloring <- list(color_test)
  names(coloring) <- group
  heatmap_df <- assay(vsd)[genes,]
  if(!("all" %in% plot_groups)){
    sample_info <- colData(dds)
    sample_plot <- sample_info[sample_info[[group]] %in% plot_groups, ]
    heatmap_df <- heatmap_df[ , rownames(sample_plot)]
  } else {
    sample_plot <- sample_info
  }
  # Heatmaps are always mean cenetered. Meaning the value shown is actually the 
  # expression value of the sample minus the mean. This command centers the
  # dataframe so it can be plotted. When it isn't centered it is very hard to
  # see any trends because all genes have very different expression levels.
  heatmap_scale <- t(scale(t(heatmap_df), scale = TRUE))
  palOut <- colorRampPalette(blueYellow)(256)
  if(!cluster_cols){
    if(!identical(colnames(heatmap_scale), rownames(sample_plot))){
      heatmap_scale <- heatmap_scale[ , rownames(sample_plot)]
    }
    # Order based on the comparison
    col_order <- c(
      grep(control, sample_plot[[group]]),
      grep(treatment, sample_plot[[group]]),
      grep((paste0(treatment, "|", control)), sample_plot[[group]],
           invert = TRUE)
    )
    heatmap_scale <- heatmap_scale[ , col_order]
  }
  if(print_genenames){
    gene_names <- rownames(heatmap_scale)
    if(gene_identifier == "Gene_ID"){
      gene_names <- sub("_ENSMUSG[0-9]*", "", gene_names)
    } else if (gene_identifier == "ENS_ID"){
      gene_names <- sub("*_ENSMUSG", "ENSMUSG", gene_names)
    }
    rownames(heatmap_scale) <- gene_names
  }
  # Here we make the heatmap
  heatmap <- pheatmap(heatmap_scale, cluster_rows = TRUE,
                      cluster_cols = cluster_cols,
                      show_rownames = print_genenames,
                      show_colnames = TRUE, annotation_col = df,
                      annotation_colors = coloring, color = blueYellow,
                      border_color = NA, clustering_method = "complete")
  
  if(save_heatmap){
    comparison <- paste0(control, "_vs_", treatment, ".pdf")
    pdf(file.path(output_dir, comparison), width = 10, height = 10)
    print(heatmap)
    dev.off()
  }
  
  return(heatmap)
}

# Run gprofiler separate positive and negative
run_gprofiler <- function(gene_table, pos_name, neg_name,
                          custom_bg = FALSE, 
                          correction_method = "gSCS",
                          exclude_iea = FALSE,
                          save_dir = NULL,
                          plot_dir = NULL){
  pos_sig_table <- gene_table[gene_table$log2FoldChange > 0, ]
  neg_sig_table <- gene_table[gene_table$log2FoldChange < 0, ]
  
  # Here we order by the log fold change so that "ordered_query" can be true
  pos_sig_table <- pos_sig_table[order(pos_sig_table$log2FoldChange),]
  neg_sig_table <- neg_sig_table[order(neg_sig_table$log2FoldChange),]
  pos_sig_genes <- rev(pos_sig_table$ens_id)
  neg_sig_genes <- neg_sig_table$ens_id
  pos_gost <- gost(query = pos_sig_genes,
                   organism = "mmusculus",
                   ordered_query = TRUE,
                   exclude_iea = exclude_iea,
                   user_threshold = 0.05,
                   correction_method = correction_method,
                   custom_bg = custom_bg)
  
  neg_gost <- gost(query = neg_sig_genes,
                   organism = "mmusculus",
                   ordered_query = TRUE,
                   exclude_iea = exclude_iea,
                   user_threshold = 0.05,
                   correction_method = correction_method,
                   custom_bg = custom_bg)
  
  sig_pos_res <- pos_gost$result[pos_gost$result$significant == TRUE, ]
  sig_neg_res <- neg_gost$result[neg_gost$result$significant == TRUE, ]
  
  if (!is.null(save_dir)){
    pos_save <- paste0(pos_name, "_from_", pos_name, "_vs_", neg_name, ".csv")
    neg_save <- paste0(neg_name, "_from_", pos_name, "_vs_", neg_name, ".csv")
    pos_save_rds <- paste0(pos_name, "_from_", pos_name, "_vs_",
                           neg_name, ".rds")
    neg_save_rds <- paste0(neg_name, "_from_", pos_name, "_vs_",
                           neg_name, ".rds")
    saveRDS(pos_gost, file = file.path(save_dir,pos_save_rds))
    saveRDS(neg_gost, file = file.path(save_dir, neg_save_rds))
    if(nrow(sig_pos_res) > 1){
      sig_pos_res_csv <- apply(sig_pos_res, 2, as.character)
      write.csv(sig_pos_res_csv, file = file.path(save_dir, pos_save))
    }
    if(nrow(sig_neg_res) > 1){
      sig_neg_res_csv <- apply(sig_neg_res, 2, as.character)
      write.csv(sig_neg_res_csv, file = file.path(save_dir, neg_save))
    }
  }
  if (!is.null(plot_dir)){
    save_name <- paste0(pos_name, "_vs_", neg_name, "_separate.pdf")
    
    # This opens up a pdf file. We will save many images into this file
    pdf(file.path(plot_dir, save_name))
    
    # These make the plots
    plots <- list()
    plots$C_GOBP <- gost_plots(sig_pos_res, "GO:BP", pos_name)
    plots$C_GOMF <- gost_plots(sig_pos_res, "GO:MF", pos_name)
    plots$C_GOCC <- gost_plots(sig_pos_res, "GO:CC", pos_name)
    plots$C_KEGG <- gost_plots(sig_pos_res, "KEGG", pos_name)
    plots$C_TF <- gost_plots(sig_pos_res, "TF", pos_name)
    plots$T_GOBP <- gost_plots(sig_neg_res, "GO:BP", neg_name)
    plots$T_GOMF <- gost_plots(sig_neg_res, "GO:MF", neg_name)
    plots$T_GOCC <- gost_plots(sig_neg_res, "GO:CC", neg_name)
    plots$T_KEGG <- gost_plots(sig_neg_res, "KEGG", neg_name)
    plots$T_TF <- gost_plots(sig_neg_res, "TF", neg_name)
    
    plots_list <- lapply(plots, function(x){
      if (!is.null(x)){
        plot(x)
      }
    })
    
    # This closes the pdf
    dev.off()
    

  }
  return_list <- list(pos_gost, neg_gost)
  names(return_list) <- c(pos_name, neg_name)
  return_list$plots <- plots_list
  return(return_list)
  
}

# Run gprofiler on all DE genes
run_gprofiler_all <- function(gene_table, pos_name, neg_name,
                             custom_bg = FALSE, 
                             correction_method = "gSCS",
                             exclude_iea = FALSE,
                             save_dir = NULL,
                             plot_dir = NULL){
  
  # Here we order by the log fold change so that "ordered_query" can be true
  gene_table <- gene_table[order(gene_table$log2FoldChange),]
  sig_genes <- rev(gene_table$ens_id)
  gost_res <- gost(query = sig_genes,
                   organism = "mmusculus",
                   ordered_query = TRUE,
                   exclude_iea = exclude_iea,
                   user_threshold = 0.05,
                   correction_method = correction_method,
                   custom_bg = custom_bg)
  
  sig_res <- gost_res$result[gost_res$result$significant == TRUE, ]

  if (!is.null(save_dir)){
    save_name <- paste0(pos_name, "_vs_", neg_name, ".csv")
    save_rds <- paste0(pos_name, "_vs_", neg_name, ".rds")
    saveRDS(gost_res, file = file.path(save_dir, save_rds))
    if(nrow(sig_res) > 1){
      sig_res_csv <- apply(sig_res, 2, as.character)
      write.csv(sig_res_csv, file = file.path(save_dir, save_name))
    }
  }
  if (!is.null(plot_dir)){
    save_name <- paste0(pos_name, "_vs_", neg_name, ".pdf")
    
    # This opens up a pdf file. We will save many images into this file
    pdf(file.path(plot_dir, save_name))
    
    # These make the plots
    plots <- list()
    plot_name <- paste0(pos_name, "_vs_", neg_name)
    plots$GOBP <- gost_plots(sig_res, "GO:BP", plot_name)
    plots$GOMF <- gost_plots(sig_res, "GO:MF", plot_name)
    plots$GOCC <- gost_plots(sig_res, "GO:CC", plot_name)
    plots$KEGG <- gost_plots(sig_res, "KEGG", plot_name)
    plots$TF <- gost_plots(sig_res, "TF", plot_name)
    
    plots_list <- lapply(plots, function(x){
      if (!is.null(x)){
        plot(x)
      }
    })
    
    # This closes the pdf
    dev.off()
    

  }
  return_list <- list(gost_res)
  names(return_list) <- c(plot_name)
  return_list$plots <- plots_list
  return(return_list)
  
}

gost_plots <- function(results_table, source, title){
  source_results <- results_table[grep(source, results_table$source), ]
  if (nrow(source_results) > 0) {
    source_results <- source_results[order(source_results$precision), ]
    source_results <- source_results[1:40, ]
    source_results$term_name <- factor(source_results$term_name, levels = 
                                   unique(source_results$term_name))
    source_results$log_padj <- -log10(source_results$p_value)
    go_plot <-ggplot(source_results, aes(x = precision,
                                         y = term_name,
                                         color = log_padj,
                                         size = intersection_size)) +
      geom_point() +
      theme_classic() +
      scale_size(name = "Intersection",
                 range(c(1,max(source_results$intersection_size)))) +
      viridis::scale_color_viridis() +
      theme(text = ggplot2::element_text(size = 10)) +
      ggtitle(paste0(source, ": ", title)) +
      labs(color = "-log10(p-value)") +
      xlab("Precision (proportion of genes)") +
      ylab("Term")


    
    return(go_plot)
  }
}

# Make gene plots
plot_genes <- function(gene_id, gene_id_list, deseq_obj,
                       intgroup, plot_ggplot = TRUE,
                       color = NULL, return_data = TRUE,
                       print = TRUE, save_path = NULL){
  # Locate the index of the gene of interest
  index <- grep(paste0("^", gene_id, "$"), gene_id_list)
  if(length(index) == 0){
    print(paste0(gene_id, " not in deseq object"))
    return(NULL)
  } else if(length(index == 1)) {
    counts_plot <- make_plots(index = index, deseq_obj = deseq_obj,
                              intgroup = intgroup, plot_ggplot = plot_ggplot,
                              color = color, return_data = return_data,
                              print = print, save_path = save_path)
    return(counts_plot)
  } else {
    # This is in case a gene has two ensembl values
    plot_list <- lapply(index, function(x) make_plots(index = x,
                                                     deseq_obj = deseq_obj,
                                                     intgroup = intgroup,
                                                     plot_ggplot = plot_ggplot,
                                                     color = color, 
                                                     return_data = return_data,
                                                     print = print,
                                                     save_path = save_path))
    return(plot_list)
  }
}
make_plots <- function(index, deseq_obj, intgroup, plot_ggplot,
                       color, return_data, print, save_path){
  gene_name <- rownames(deseq_obj)[index]
  counts_plot <- DESeq2::plotCounts(deseq_obj, gene = gene_name,
                                    intgroup = intgroup,
                                    returnData = TRUE)
  if(plot_ggplot){
  if(is.null(color)){
    color <- brewer.pal(length(levels(deseq_obj[[group_by]])), "Set1")
    names(color) <- levels(deseq_obj[[group_by]])
  }
    colnames(counts_plot) <- c("count", "Group")
    ggplot_counts_plot <- ggplot2::ggplot(counts_plot,
                                          ggplot2::aes(x = Group,
                                                       y = count)) +
      ggplot2::geom_point(ggplot2::aes(color = Group), size = 3) +
      ggplot2::scale_color_manual(values = color, name = "Group") +
      ggplot2::theme_classic() +
      ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45,
                                                vjust = 1,
                                                hjust=1)) +
      ggplot2::ggtitle(gene_name)
    if(print){
      print(ggplot_counts_plot)
    }
    if (!is.null(save_path)){
      file_name <- paste0("counts_plot_", gene_name, ".pdf")
      file_path <- file.path(save_path, file_name)
      ggplot2::ggsave(filename = file_path, plot = ggplot_counts_plot)
    }
    if(return_data){
      return(ggplot_counts_plot)
    }
  } else {
    return(counts_plot)
  }
}

################
# Theme colors #
################

# Colors for heatmap (from the ArchR package)
blueYellow <- c("#352A86", "#343DAE", "#0262E0", "#1389D2", "#2DB7A3",
	"#A5BE6A", "#F8BA43", "#F6DA23", "#F8FA0D")

# Colors for statistics
fastqc_colors <- c("#e31a1c", "#238443", "#ec7014")

star_colors <- c("#737373", "#8c6bb1", "#ec7014",
                 "#e31a1c", "#238443", "#225ea8")
```


## Background
This documents the analysis of the effect of cytokine treatment on PTPN2 KO mice.
This document aims to analyze differences between PTPN2 KO and WT mice in their
response to cytokine treatment.

```{r, "Load in and set up data"}
# Load in the files
###############
# Count table #
###############
# Read in the count table
count_table <- read.table(params$counts, sep = "\t", row.names = 1, header = T)

################
# Sample table #
################

# Read in the sample table
sample_table <- read.table(params$sample_info, sep = ",", header = T,
                           row.names = 1)

# Ensure the count table and sample table are in the same order
count_table <- count_table[ , rownames(sample_table)]

########
# Star #
########

# Read in star stats
star_stats <- read.table(params$star_stats, sep = "\t", row.names = 1,
                         header = T)

# Filter for mapping % and total read counts
star_stats <- star_stats[grepl(
  "%|Uniquely mapped reads|mapped to multiple loci",
  rownames(star_stats)), ]

star_stats <- star_stats[!grepl(
  "^Mismatch|chimeric", rownames(star_stats)), ]

# Calculate median size
star_stats_median <- star_stats[grepl(
  "Uniquely mapped reads", rownames(star_stats)), ]

median_size <- median(as.numeric(
  star_stats_median["Uniquely mapped reads number", ])) / 1000000

median_rate <- median(as.numeric(str_remove(
  star_stats_median["Uniquely mapped reads %", ], "%")))

alignment_qual <- get_alignment_qual(median_rate)

# Pull out all sample names
samples <- colnames(star_stats)

# Make a column of metrics
star_stats$metric <- rownames(star_stats)

# Make into long form for ggplot
star_stats_long <- gather(star_stats, key = "Sample", value = "value",
                          all_of(samples))


# Add column for value type
star_stats_long <- star_stats_long %>%
  mutate(
    value = as.numeric(str_remove(value, "%")),
    val_type = ifelse(grepl("%", metric),
                      "pct", "int")
  )

# Pull out read counts
# Calculate median library size
read_counts <- star_stats_long %>%
  filter(grepl("mapped reads number", metric)) %>%
  mutate(value = round(value / 1000000)) %>%
  mutate(value = str_c(value, " million"))

##########
# FastQC #
##########

# Load in fastqc results
fastqc_summary <- read.table(params$fastqc, sep = "\t")

# Change the colnames
colnames(fastqc_summary) <- c("Result", "Test", "Sample")

# Update sample names
fastqc_summary$Sample <- sub("_S[0-9]*_L[0-9]*_", "", fastqc_summary$Sample)
fastqc_summary$Sample <- sub("_001.fastq.gz", "", fastqc_summary$Sample)

##############
# Set colors #
##############
sample_table[[params$sample_column]] <- 
  factor(sample_table[[params$sample_column]])
sample_colors <- brewer.pal(length(
  levels(sample_table[[params$sample_column]])), "Set1")
names(sample_colors) <- levels(sample_table[[params$sample_column]])

```

# Quality Control {.tabset}

## FastQC Summary
`FastQC` was used to assess the quality of each fastq file. A summary of the results is shown below, the overall library quality was **`r params$library_quality`**.
```{r "Create fastqc summary", fig.width = 8.5, fig.height = 3}
fastqc_plot <- ggplot(data = fastqc_summary,
                      mapping = aes(x = Sample,
                                    y = Test,
                                    fill = Result)) +
  geom_tile(color = "white", size = 0.5) +
  scale_fill_manual(values = fastqc_colors) +
  theme_classic() +
  theme(
    legend.title = element_blank(),
    legend.text  = element_text(size = 8, color = "black"),
    axis.title   = element_blank(),
    axis.text    = element_text(size = 8, color = "black"),
    axis.text.x  = element_text(angle = 90, hjust = 1, vjust = 0.5)
  )

fastqc_plot
```


## Alignment Summary
Reads were aligned to the `r params$genome` genome using the `STAR` RNA-seq aligner. A summary of the results is shown below, the library size is displayed on each bar. The median library size was `r median_size` million reads and the median alignment rate was `r median_rate`. Overall, the alignment rate was **`r alignment_qual`**. 
```{r "Create alignment summary", fig.width = 8.5, fig.height = 3}

# Plot alignment stats
star_stats_long_pct <- star_stats_long %>%
  filter(val_type == "pct") %>%
  
  # Add median rates to metric label
  mutate(
    metric = str_remove(metric, "% of reads | reads %"),
    metric = str_to_sentence(metric)
  ) %>%
  arrange(value) %>%
  mutate(metric = fct_inorder(metric))
  
# Plot STAR alignment stats
star_plot <- ggplot(data = star_stats_long_pct,
                    mapping = aes(x = Sample,
                                  y = value,
                                  fill = metric)) +
  geom_bar(stat = "identity", color = "white", size = 0.5) +
  
  # Label bars with library size
  geom_text(
    data = read_counts, 
    aes(Sample, 50, label = value),
    show.legend = F,
    inherit.aes = F,
    color = "white", 
    angle = 90
  ) +
  
  scale_fill_manual(
    values = star_colors,
    guide  = guide_legend(reverse = T)
  ) +
  scale_y_continuous(labels = function(x) {str_c(x, "%")}) +
  theme_classic() +
  theme(
    legend.title = element_blank(),
    legend.text  = element_text(size = 8, color = "black"),
    axis.title   = element_blank(),
    axis.text    = element_text(size = 8, color = "black"),
    axis.text.x  = element_text(angle = 90, hjust = 1, vjust = 0.5)
  )

star_plot

```


## PCA
Principal component analysis was performed to assess similarities between samples. Biological replicates were plotted for each experimental condition. When replicates cluster close together, this suggests that overall gene expression patterns are fairly reproducible.

```{r "Run DESeq2 and create PCA plot", fig.width = 6, fig.height = 4}
# This makes a DESeq2 object where the count data is our count matrix and the colData is our sample data. I am currently making the design based on "group" but we can change this if necessary
dds <- DESeqDataSetFromMatrix(countData = count_table,
                              colData = sample_table,
                              design = formula(paste("~",
                                                     params$sample_column)))
# Here we get rid of all the genes that are not expressed
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]
dds <- DESeq(dds)
# This transforms the counts to have constant variance. This helps ensue that highly or lowly expressed genes will not contribute too much for the PCA or clustering analysis
vsd <- vst(dds, blind = F)

plot_pca(vsd, group_by = params$sample_column, color_palette = sample_colors)
```


## Sample Distances
Correlations between samples was determined to further assess similarities between samples. Biological replicates should cluster together. Samples that are more similar to each other have values closer to 0. 

```{r "Determine distance between samples", fig.width= 6, fig.height = 4}
# This determines distance between samples.
get_distances(vsd)
```

# Differential Expression Analysis {.tabset}


```{r "Make directories", include = F}
# Create the output folders if it doesn't already exist
ifelse(!dir.exists(file.path(params$output_dir, "DE_files")),
       dir.create(file.path(params$output_dir, "DE_files")), FALSE)

ifelse(!dir.exists(file.path(params$output_dir, "images")),
       dir.create(file.path(params$output_dir, "images")), FALSE)
ifelse(!dir.exists(file.path(params$output_dir, "images", "heatmaps")),
       dir.create(file.path(params$output_dir, "images",
                            "heatmaps")), FALSE)
ifelse(!dir.exists(file.path(params$output_dir, "images", "GSE")),
       dir.create(file.path(params$output_dir, "images", "GSE")), FALSE)
ifelse(!dir.exists(file.path(params$output_dir, "GSE_files")),
       dir.create(file.path(params$output_dir, "GSE_files")), FALSE)
```

```{r "Run differential experession chunks", echo = F}
DE_chunks <- params$comparisons %>%
  map(~knit_expand("src/rules/scripts/DESeq_template.Rmd"))
```

`r knit_child(text = DE_chunks)`


# Gene plots {.tabset}
Gene plots show the normalized expression of key genes across all samples. We can add in any genes that you would like to see in this format.
```{r "Make gene directories", include = F}
ifelse(!dir.exists(file.path(params$output_dir, "images", "gene_plots")),
       dir.create(file.path(params$output_dir, "images", "gene_plots")), FALSE)


```

```{r "Run gene experession chunks", echo = F}
gene_chunks <- params$genes %>%
  map(~knit_expand("src/rules/scripts/gene_plots_template.Rmd"))
```

`r knit_child(text = gene_chunks)`

# Session Info

```{r}
sessionInfo()
```